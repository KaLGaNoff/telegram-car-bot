import os
import json
import time
import logging
import warnings
import gspread
from datetime import datetime, timedelta
import pytz
import threading
import asyncio
from queue import Queue
import requests
from flask import Flask, request
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler, MessageHandler,
    filters, ContextTypes, ConversationHandler
)

# –ü—Ä–∏–¥—É—à–µ–Ω–Ω—è PTBUserWarning
warnings.filterwarnings("ignore", category=UserWarning)

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

class FaviconFilter(logging.Filter):
    def filter(self, record):
        return '/favicon' not in record.getMessage()

log_handler = logging.StreamHandler()
log_handler.setFormatter(logging.Formatter(
    "%(asctime)s - %(levelname)s - %(message)s"
))
log_handler.addFilter(FaviconFilter())
logger.addHandler(log_handler)

logger.info("–ë–æ—Ç –∑–∞–ø—É—Å–∫–∞—î—Ç—å—Å—è...")

# –ó–º—ñ–Ω–Ω—ñ –æ—Ç–æ—á–µ–Ω–Ω—è
OWNER_ID = 270380991
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
GOOGLE_SHEET_ID = os.getenv("GOOGLE_SHEET_ID")
SERVICE_ACCOUNT_JSON = os.getenv("SERVICE_ACCOUNT_JSON")
RENDER_PORT = os.getenv("PORT", "10000")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")

if not all([TELEGRAM_TOKEN, GOOGLE_SHEET_ID, SERVICE_ACCOUNT_JSON, WEBHOOK_URL]):
    logger.error("–í—ñ–¥—Å—É—Ç–Ω—ñ –æ–±–æ–≤'—è–∑–∫–æ–≤—ñ –∑–º—ñ–Ω–Ω—ñ –æ—Ç–æ—á–µ–Ω–Ω—è")
    raise ValueError("–í—ñ–¥—Å—É—Ç–Ω—ñ –æ–±–æ–≤'—è–∑–∫–æ–≤—ñ –∑–º—ñ–Ω–Ω—ñ –æ—Ç–æ—á–µ–Ω–Ω—è")

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è Google Sheets
try:
    credentials = json.loads(SERVICE_ACCOUNT_JSON)
    client = gspread.service_account_from_dict(credentials)
    sheet = client.open_by_key(GOOGLE_SHEET_ID).sheet1
    logger.info("–£—Å–ø—ñ—à–Ω–æ –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ Google Sheets")
except Exception as e:
    logger.error(f"–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó Google Sheets: {e}")
    raise

# –ö–µ—à—É–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö —Ç–∞–±–ª–∏—Ü—ñ
sheet_cache = None

def update_sheet_cache():
    global sheet_cache
    try:
        start_time = time.time()
        sheet_cache = sheet.get_all_values()
        logger.info(f"–ö–µ—à —Ç–∞–±–ª–∏—Ü—ñ –æ–Ω–æ–≤–ª–µ–Ω–æ –∑–∞ {time.time() - start_time:.3f} —Å–µ–∫")
    except Exception as e:
        logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –∫–µ—à—É: {e}")
        sheet_cache = []

update_sheet_cache()

# –°—Ç–∞–Ω–∏ –¥–ª—è ConversationHandler
WAITING_FOR_ODOMETER, WAITING_FOR_DISTRIBUTION, CONFIRMATION = range(3)
user_data_store = {}

# –ß–µ—Ä–≥–∞ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω—å
update_queue = Queue()

# –°—Ç–≤–æ—Ä—é—î–º–æ Flask –¥–æ–¥–∞—Ç–æ–∫
app = Flask(__name__)

# –°—Ç–≤–æ—Ä—é—î–º–æ Application –¥–ª—è –±–æ—Ç–∞
application = Application.builder().token(TELEGRAM_TOKEN).build()

# –§—É–Ω–∫—Ü—ñ—ó –æ–±—Ä–æ–±–Ω–∏–∫–∏
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"–û—Ç—Ä–∏–º–∞–Ω–æ –∫–æ–º–∞–Ω–¥—É /start –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {update.effective_user.id}")
    if update.effective_user.id != OWNER_ID:
        await update.message.reply_text("‚ùå *–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É –¥–æ —Ü—å–æ–≥–æ –±–æ—Ç–∞.*", parse_mode="Markdown")
        logger.warning(f"–ù–µ—Å–∞–Ω–∫—Ü—ñ–æ–Ω–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç—É–ø: {update.effective_user.id}")
        return

    keyboard = [
        [InlineKeyboardButton("üü¢ –î–æ–¥–∞—Ç–∏ –ø—Ä–æ–±—ñ–≥", callback_data="add"), InlineKeyboardButton("üî¥ –í–∏–¥–∞–ª–∏—Ç–∏", callback_data="delete")],
        [InlineKeyboardButton("üìä –ó–≤—ñ—Ç", callback_data="report"), InlineKeyboardButton("üßæ –û—Å—Ç–∞–Ω–Ω—ñ–π", callback_data="last")],
        [InlineKeyboardButton("üìà –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="stats"), InlineKeyboardButton("‚ôªÔ∏è –°–∫–∏–Ω—É—Ç–∏", callback_data="reset")],
        [InlineKeyboardButton("‚ÑπÔ∏è –î–æ–ø–æ–º–æ–≥–∞", callback_data="help")]
    ]
    await update.message.reply_text(
        "üöó *–í—ñ—Ç–∞—é —É —Ç–≤–æ—î–º—É –∞–≤—Ç–æ-–±–æ—Ç—ñ!* üëã\n–û–±–µ—Ä–∏ –¥—ñ—é –Ω–∏–∂—á–µ:",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {update.effective_user.id} –∑–∞–ø—É—Å—Ç–∏–≤ –±–æ—Ç–∞")

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"–û—Ç—Ä–∏–º–∞–Ω–æ –∫–æ–º–∞–Ω–¥—É /stats –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {update.effective_user.id}")
    if update.effective_user.id != OWNER_ID:
        await update.message.reply_text("‚ùå *–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É.*", parse_mode="Markdown")
        logger.warning(f"–ù–µ—Å–∞–Ω–∫—Ü—ñ–æ–Ω–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ /stats: {update.effective_user.id}")
        return

    if not sheet_cache:
        await update.message.reply_text("üìà *–¢–∞–±–ª–∏—Ü—è –ø–æ—Ä–æ–∂–Ω—è.* üòï", parse_mode="Markdown")
        logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {update.effective_user.id} —Å–ø—Ä–æ–±—É–≤–∞–≤ –ø–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É: —Ç–∞–±–ª–∏—Ü—è –ø–æ—Ä–æ–∂–Ω—è")
        return

    try:
        total_distance = 0
        city_km = district_km = highway_km = 0
        city_fuel = district_fuel = highway_fuel = 0
        days = set()
        last_7_days_distance = 0
        last_7_days_fuel = 0
        eest = pytz.timezone("Europe/Kiev")
        today = datetime.now(eest)
        seven_days_ago = today - timedelta(days=7)

        for row in sheet_cache[1:]:  # –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫
            date_str = row[0]
            try:
                row_date = datetime.strptime(date_str, "%d.%m.%Y").replace(tzinfo=eest)
                days.add(date_str)
                distance = float(row[2]) if row[2] else 0
                total_distance += distance
                city_km += float(row[3]) if row[3] else 0
                district_km += float(row[6]) if row[6] else 0
                highway_km += float(row[9]) if row[9] else 0
                city_fuel += float(row[4].replace(',', '.')) if row[4] else 0
                district_fuel += float(row[7].replace(',', '.')) if row[7] else 0
                highway_fuel += float(row[10].replace(',', '.')) if row[10] else 0

                if row_date >= seven_days_ago:
                    last_7_days_distance += distance
                    last_7_days_fuel += float(row[12].replace(',', '.')) if row[12] else 0
            except ValueError as e:
                logger.warning(f"–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç–∏ –≤ —Ä—è–¥–∫—É {row}: {e}")
                continue

        avg_daily_distance = total_distance / len(days) if days else 0
        total_km = city_km + district_km + highway_km
        city_percent = (city_km / total_km * 100) if total_km else 0
        district_percent = (district_km / total_km * 100) if total_km else 0
        highway_percent = (highway_km / total_km * 100) if total_km else 0

        def progress_bar(percent, emoji):
            filled = int(percent / 10)
            return emoji * filled + "‚¨ú" * (10 - filled)

        text = (
            f"üìà *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–æ–±—ñ–≥—É* üöó\n\n"
            f"üìè *–ó–∞–≥–∞–ª—å–Ω–∏–π –ø—Ä–æ–±—ñ–≥*: {total_distance:.1f} –∫–º\n"
            f"üìÖ *–°–µ—Ä–µ–¥–Ω—ñ–π –∑–∞ –¥–µ–Ω—å*: {avg_daily_distance:.1f} –∫–º\n"
            f"üõ£ *–ü—Ä–æ–±—ñ–≥ –∑–∞ —Ç–∏–ø–æ–º –¥–æ—Ä–æ–≥–∏*:\n"
            f"  üèô *–ú—ñ—Å—Ç–æ*: {city_km:.1f} –∫–º ({city_fuel:.2f} –ª) `{progress_bar(city_percent, 'üü¶')} {city_percent:.1f}%`\n"
            f"  üå≥ *–†–∞–π–æ–Ω*: {district_km:.1f} –∫–º ({district_fuel:.2f} –ª) `{progress_bar(district_percent, 'üü©')} {district_percent:.1f}%`\n"
            f"  üõ£ *–¢—Ä–∞—Å–∞*: {highway_km:.1f} –∫–º ({highway_fuel:.2f} –ª) `{progress_bar(highway_percent, 'üüß')} {highway_percent:.1f}%`\n"
            f"üìÜ *–û—Å—Ç–∞–Ω–Ω—ñ 7 –¥–Ω—ñ–≤*:\n"
            f"  üîÑ –ü—Ä–æ–±—ñ–≥: {last_7_days_distance:.1f} –∫–º\n"
            f"  ‚õΩ –í–∏—Ç—Ä–∞—Ç–∏ –ø–∞–ª—å–Ω–æ–≥–æ: {last_7_days_fuel:.2f} –ª\n"
        )
        await update.message.reply_text(text, parse_mode="Markdown")
        logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {update.effective_user.id} –ø–µ—Ä–µ–≥–ª—è–Ω—É–≤ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É")
    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è *–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏*: {e}", parse_mode="Markdown")
        logger.error(f"–ü–æ–º–∏–ª–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")

async def handle_button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    logger.info(f"–û—Ç—Ä–∏–º–∞–Ω–æ callback: {query.data} –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {query.from_user.id}")

    if query.from_user.id != OWNER_ID:
        await query.edit_message_text("‚ùå *–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É.*", parse_mode="Markdown")
        logger.warning(f"–ù–µ—Å–∞–Ω–∫—Ü—ñ–æ–Ω–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ –∫–Ω–æ–ø–∫–∏: {query.from_user.id}")
        return

    data = user_data_store.get(query.from_user.id, {})

    if query.data == "add":
        keyboard = [[InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]]
        last_odo = int(float(sheet_cache[-1][1])) if len(sheet_cache) >= 2 else None
        last_odo_text = f"üìç *–¢–≤—ñ–π –æ—Å—Ç–∞–Ω–Ω—ñ–π –æ–¥–æ–º–µ—Ç—Ä*: {last_odo}" if last_odo else "üìç *–¶–µ —Ç–≤—ñ–π –ø–µ—Ä—à–∏–π –∑–∞–ø–∏—Å!*"
        await query.edit_message_text(
            f"{last_odo_text}\n\nüìè *–í–≤–µ–¥–∏ –ø–æ—Ç–æ—á–Ω–∏–π –æ–¥–æ–º–µ—Ç—Ä* (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `53200`):",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return WAITING_FOR_ODOMETER

    elif query.data == "delete":
        if sheet_cache:
            try:
                start_time = time.time()
                sheet.delete_rows(len(sheet_cache))
                update_sheet_cache()
                await query.edit_message_text("üóë *–û—Å—Ç–∞–Ω–Ω—ñ–π –∑–∞–ø–∏—Å –≤–∏–¥–∞–ª–µ–Ω–æ!* ‚úÖ")
                logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {query.from_user.id} –≤–∏–¥–∞–ª–∏–≤ –æ—Å—Ç–∞–Ω–Ω—ñ–π –∑–∞–ø–∏—Å –∑–∞ {time.time() - start_time:.3f} —Å–µ–∫")
            except Exception as e:
                await query.edit_message_text(f"‚ö†Ô∏è *–ü–æ–º–∏–ª–∫–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è*: {e}", parse_mode="Markdown")
                logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞–ø–∏—Å—É: {e}")
        else:
            await query.edit_message_text("üìà *–¢–∞–±–ª–∏—Ü—è –ø–æ—Ä–æ–∂–Ω—è.* üòï", parse_mode="Markdown")

    elif query.data == "report" or query.data == "last":
        if not sheet_cache:
            await query.edit_message_text("üìà *–¢–∞–±–ª–∏—Ü—è –ø–æ—Ä–æ–∂–Ω—è.* üòï", parse_mode="Markdown")
            return
        text = "üìä *–û—Å—Ç–∞–Ω–Ω—ñ –∑–∞–ø–∏—Å–∏*:\n\n```\n–î–∞—Ç–∞       | –û–¥–æ–º–µ—Ç—Ä | –ü—Ä–æ–±—ñ–≥ | –ú—ñ—Å—Ç–æ | –í–∏—Ç—Ä–∞—Ç–∏\n"
        for row in sheet_cache[-5:]:
            text += f"{row[0]:<11}| {row[1]:<8}| {row[2]:<7}| {row[3]:<6}| {row[4]}\n"
        text += "```"
        await query.edit_message_text(text, parse_mode="Markdown")
        logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {query.from_user.id} –ø–µ—Ä–µ–≥–ª—è–Ω—É–≤ –∑–≤—ñ—Ç")

    elif query.data == "stats":
        await stats(update, context)

    elif query.data == "reset":
        user_data_store.pop(query.from_user.id, None)
        await query.edit_message_text("‚ôªÔ∏è *–î–∞–Ω—ñ —Å–∫–∏–Ω—É—Ç–æ!* ‚úÖ", parse_mode="Markdown")
        logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {query.from_user.id} —Å–∫–∏–Ω—É–≤ –¥–∞–Ω—ñ")

    elif query.data == "help":
        await query.edit_message_text(
            "‚ÑπÔ∏è *–Ø–∫ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—è –±–æ—Ç–æ–º*:\n"
            "1. –ù–∞—Ç–∏—Å–Ω–∏ üü¢ *–î–æ–¥–∞—Ç–∏ –ø—Ä–æ–±—ñ–≥*.\n"
            "2. –í–≤–µ–¥–∏ –æ–¥–æ–º–µ—Ç—Ä (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `53200`).\n"
            "3. –í–∫–∞–∂–∏ —Ä–æ–∑–ø–æ–¥—ñ–ª: *–º—ñ—Å—Ç–æ* 50 *—Ä–∞–π–æ–Ω* 30 *—Ç—Ä–∞—Å–∞* 6.\n"
            "4. –°—É–º–∞ –º–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—Ç–∏ —Ä—ñ–∑–Ω–∏—Ü—ñ –æ–¥–æ–º–µ—Ç—Ä–∞.\n"
            "üìà *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞* –ø–æ–∫–∞–∂–µ —Ç–≤–æ—ó –ø–æ—ó–∑–¥–∫–∏!",
            parse_mode="Markdown"
        )

    elif query.data == "retry_odometer":
        keyboard = [[InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]]
        last_odo = int(float(sheet_cache[-1][1])) if len(sheet_cache) >= 2 else None
        last_odo_text = f"üìç *–¢–≤—ñ–π –æ—Å—Ç–∞–Ω–Ω—ñ–π –æ–¥–æ–º–µ—Ç—Ä*: {last_odo}" if last_odo else "üìç *–¶–µ —Ç–≤—ñ–π –ø–µ—Ä—à–∏–π –∑–∞–ø–∏—Å!*"
        await query.edit_message_text(
            f"{last_odo_text}\n\nüìè *–í–≤–µ–¥–∏ –ø–æ—Ç–æ—á–Ω–∏–π –æ–¥–æ–º–µ—Ç—Ä* (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `53200`):",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return WAITING_FOR_ODOMETER

    elif query.data == "retry_distribution":
        user_id = query.from_user.id
        data = user_data_store.get(user_id, {})
        if not data:
            await query.edit_message_text("‚ö†Ô∏è *–î–∞–Ω—ñ –∑–∞–≥—É–±–ª–µ–Ω–æ. –ü–æ—á–Ω–∏ –∑–Ω–æ–≤—É.*", parse_mode="Markdown")
            logger.warning(f"–î–∞–Ω—ñ –∑–∞–≥—É–±–ª–µ–Ω–æ –¥–ª—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {user_id}")
            return ConversationHandler.END
        prev_odo = int(float(sheet_cache[-1][1])) if len(sheet_cache) >= 2 else 0
        keyboard = [[InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]]
        await query.edit_message_text(
            f"üìè *–ü–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –æ–¥–æ–º–µ—Ç—Ä*: {prev_odo}\n"
            f"üìç *–ü–æ—Ç–æ—á–Ω–∏–π –æ–¥–æ–º–µ—Ç—Ä*: {data['odometer']}\n"
            f"üîÑ *–ü—Ä–æ–±—ñ–≥ –∑–∞ –ø–µ—Ä—ñ–æ–¥*: {data['diff']} –∫–º\n\n"
            f"üõ£ *–í–≤–µ–¥–∏ —Ä–æ–∑–ø–æ–¥—ñ–ª –ø—Ä–æ–±—ñ–≥—É* (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, *–º—ñ—Å—Ç–æ* {int(data['diff']/3)} *—Ä–∞–π–æ–Ω* {int(data['diff']/3)} *—Ç—Ä–∞—Å–∞* {int(data['diff']/3)}):\n"
            f"‚ÑπÔ∏è –°—É–º–∞ –º–∞—î –¥–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ {data['diff']} –∫–º.",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return WAITING_FOR_DISTRIBUTION

async def handle_odometer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"–û—Ç—Ä–∏–º–∞–Ω–æ –≤–≤–µ–¥–µ–Ω–Ω—è –æ–¥–æ–º–µ—Ç—Ä–∞ –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {update.effective_user.id}: {update.message.text}")
    if update.effective_user.id != OWNER_ID:
        await update.message.reply_text("‚ùå *–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É.*", parse_mode="Markdown")
        logger.warning(f"–ù–µ—Å–∞–Ω–∫—Ü—ñ–æ–Ω–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ –æ–¥–æ–º–µ—Ç—Ä–∞: {update.effective_user.id}")
        return ConversationHandler.END

    text = update.message.text.strip().replace(",", ".")
    if not text.replace(".", "", 1).isdigit():
        keyboard = [
            [InlineKeyboardButton("üîÑ –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —â–µ", callback_data="retry_odometer"),
             InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]
        ]
        await update.message.reply_text(
            "üòÖ *–í–≤–µ–¥–∏ —á–∏—Å–ª–æ* (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, `53200`):",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return WAITING_FOR_ODOMETER

    odometer = int(float(text))
    rows = sheet_cache

    if len(rows) >= 2:
        prev_odo = int(float(rows[-1][1]))
    else:
        prev_odo = 0

    diff = odometer - prev_odo
    if diff <= 0:
        keyboard = [
            [InlineKeyboardButton("üîÑ –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —â–µ", callback_data="retry_odometer"),
             InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]
        ]
        await update.message.reply_text(
            f"‚ùóÔ∏è *–û–¥–æ–º–µ—Ç—Ä –º–∞—î –±—É—Ç–∏ –±—ñ–ª—å—à–∏–π –∑–∞ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ–π* ({prev_odo}).",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return WAITING_FOR_ODOMETER

    user_data_store[update.effective_user.id] = {
        "odometer": odometer,
        "diff": diff
    }

    keyboard = [[InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]]
    await update.message.reply_text(
        f"üìè *–ü–æ–ø–µ—Ä–µ–¥–Ω—ñ–π –æ–¥–æ–º–µ—Ç—Ä*: {prev_odo}\n"
        f"üìç *–ü–æ—Ç–æ—á–Ω–∏–π –æ–¥–æ–º–µ—Ç—Ä*: {odometer}\n"
        f"üîÑ *–ü—Ä–æ–±—ñ–≥ –∑–∞ –ø–µ—Ä—ñ–æ–¥*: {diff} –∫–º\n\n"
        f"üõ£ *–í–≤–µ–¥–∏ —Ä–æ–∑–ø–æ–¥—ñ–ª –ø—Ä–æ–±—ñ–≥—É* (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, *–º—ñ—Å—Ç–æ* {int(diff/3)} *—Ä–∞–π–æ–Ω* {int(diff/3)} *—Ç—Ä–∞—Å–∞* {int(diff/3)}):\n"
        f"‚ÑπÔ∏è –°—É–º–∞ –º–∞—î –¥–æ—Ä—ñ–≤–Ω—é–≤–∞—Ç–∏ {diff} –∫–º.",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )
    logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {update.effective_user.id} –≤–≤—ñ–≤ –æ–¥–æ–º–µ—Ç—Ä: {odometer}")
    return WAITING_FOR_DISTRIBUTION

async def handle_distribution(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info(f"–û—Ç—Ä–∏–º–∞–Ω–æ —Ä–æ–∑–ø–æ–¥—ñ–ª –ø—Ä–æ–±—ñ–≥—É –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {update.effective_user.id}: {update.message.text}")
    if update.effective_user.id != OWNER_ID:
        await update.message.reply_text("‚ùå *–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É.*", parse_mode="Markdown")
        logger.warning(f"–ù–µ—Å–∞–Ω–∫—Ü—ñ–æ–Ω–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ —Ä–æ–∑–ø–æ–¥—ñ–ª—É: {update.effective_user.id}")
        return ConversationHandler.END

    text = update.message.text.lower()
    user_id = update.effective_user.id
    data = user_data_store.get(user_id, {})

    if not data:
        await update.message.reply_text("‚ö†Ô∏è *–î–∞–Ω—ñ –∑–∞–≥—É–±–ª–µ–Ω–æ. –ü–æ—á–Ω–∏ –∑–Ω–æ–≤—É.*", parse_mode="Markdown")
        logger.warning(f"–î–∞–Ω—ñ –∑–∞–≥—É–±–ª–µ–Ω–æ –¥–ª—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {user_id}")
        return ConversationHandler.END

    city_km = district_km = highway_km = 0
    try:
        for word in text.split():
            if "–º—ñ—Å—Ç" in word:
                next_value = text.split(word)[1].strip().split()[0]
                city_km = float(next_value)
            elif "—Ä–∞–π–æ–Ω" in word:
                next_value = text.split(word)[1].strip().split()[0]
                district_km = float(next_value)
            elif "—Ç—Ä–∞—Å" in word:
                next_value = text.split(word)[1].strip().split()[0]
                highway_km = float(next_value)
    except (IndexError, ValueError):
        keyboard = [
            [InlineKeyboardButton("üîÑ –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —â–µ", callback_data="retry_distribution"),
             InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]
        ]
        await update.message.reply_text(
            f"üòÖ *–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç.* –í–≤–µ–¥–∏, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥: *–º—ñ—Å—Ç–æ* {int(data['diff']/3)} *—Ä–∞–π–æ–Ω* {int(data['diff']/3)} *—Ç—Ä–∞—Å–∞* {int(data['diff']/3)}",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return WAITING_FOR_DISTRIBUTION

    total_entered = city_km + district_km + highway_km
    if abs(total_entered - data["diff"]) > 1:
        keyboard = [
            [InlineKeyboardButton("üîÑ –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ —â–µ", callback_data="retry_distribution"),
             InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]
        ]
        await update.message.reply_text(
            f"‚ö†Ô∏è *–°—É–º–∞ ({total_entered}) –Ω–µ –∑–±—ñ–≥–∞—î—Ç—å—Å—è –∑ –ø—Ä–æ–±—ñ–≥–æ–º ({data['diff']}).* –í–∏–ø—Ä–∞–≤.\n"
            f"–í–≤–µ–¥–∏, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥: *–º—ñ—Å—Ç–æ* {int(data['diff']/3)} *—Ä–∞–π–æ–Ω* {int(data['diff']/3)} *—Ç—Ä–∞—Å–∞* {int(data['diff']/3)}",
            reply_markup=InlineKeyboardMarkup(keyboard),
            parse_mode="Markdown"
        )
        return WAITING_FOR_DISTRIBUTION

    def calc(litres_per_100km, km):
        exact = round(km * litres_per_100km / 100, 4)
        rounded = round(exact)
        return exact, rounded

    c_exact, c_rounded = calc(11.66, city_km)
    d_exact, d_rounded = calc(11.17, district_km)
    h_exact, h_rounded = calc(10.19, highway_km)
    total_exact = round(c_exact + d_exact + h_exact, 4)
    total_rounded = round(total_exact)

    data.update({
        "city_km": city_km, "city_exact": c_exact, "city_rounded": c_rounded,
        "district_km": district_km, "district_exact": d_exact, "district_rounded": d_rounded,
        "highway_km": highway_km, "highway_exact": h_exact, "highway_rounded": h_rounded,
        "total_exact": total_exact, "total_rounded": total_rounded
    })
    user_data_store[user_id] = data

    text = (
        f"üìã *–ù–æ–≤–∏–π –∑–∞–ø–∏—Å*:\n"
        f"üìè *–û–¥–æ–º–µ—Ç—Ä*: {data['odometer']} –∫–º\n"
        f"üîÑ *–ü—Ä–æ–±—ñ–≥*: {data['diff']} –∫–º\n"
        f"üèô *–ú—ñ—Å—Ç–æ*: {int(city_km)} –∫–º ‚Üí {c_exact} –ª (‚âà {c_rounded})\n"
        f"üå≥ *–†–∞–π–æ–Ω*: {int(district_km)} –∫–º ‚Üí {d_exact} –ª (‚âà {d_rounded})\n"
        f"üõ£ *–¢—Ä–∞—Å–∞*: {int(highway_km)} –∫–º ‚Üí {h_exact} –ª (‚âà {h_rounded})\n"
        f"‚õΩ *–ó–∞–≥–∞–ª–æ–º*: {total_exact} –ª (‚âà {total_rounded})\n\n"
        f"‚úÖ *–ó–±–µ—Ä–µ–≥—Ç–∏ –∑–∞–ø–∏—Å?*"
    )

    keyboard = [
        [InlineKeyboardButton("‚úÖ –¢–∞–∫", callback_data="confirm_yes"), InlineKeyboardButton("‚ùå –ù—ñ", callback_data="confirm_no")],
        [InlineKeyboardButton("‚ùå –°–∫–∞—Å—É–≤–∞—Ç–∏", callback_data="cancel")]
    ]
    await update.message.reply_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {user_id} –≤–≤—ñ–≤ —Ä–æ–∑–ø–æ–¥—ñ–ª: –º—ñ—Å—Ç–æ={city_km}, —Ä–∞–π–æ–Ω={district_km}, —Ç—Ä–∞—Å–∞={highway_km}")
    return CONFIRMATION

async def handle_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    logger.info(f"–û—Ç—Ä–∏–º–∞–Ω–æ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω—è: {query.data} –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {user_id}")

    if query.from_user.id != OWNER_ID:
        await query.edit_message_text("‚ùå *–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É.*", parse_mode="Markdown")
        logger.warning(f"–ù–µ—Å–∞–Ω–∫—Ü—ñ–æ–Ω–æ–≤–∞–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è: {user_id}")
        return ConversationHandler.END

    if query.data == "confirm_no" or query.data == "cancel":
        user_data_store.pop(user_id, None)
        await query.edit_message_text("‚ùå *–°–∫–∞—Å–æ–≤–∞–Ω–æ.*", parse_mode="Markdown")
        logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {user_id} —Å–∫–∞—Å—É–≤–∞–≤ –∑–∞–ø–∏—Å")
        return ConversationHandler.END

    data = user_data_store.pop(user_id, {})
    if not data:
        await query.edit_message_text("‚ö†Ô∏è *–î–∞–Ω—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ.*", parse_mode="Markdown")
        logger.warning(f"–î–∞–Ω—ñ –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –¥–ª—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {user_id}")
        return ConversationHandler.END

    eest = pytz.timezone("Europe/Kiev")
    today = datetime.now(eest).strftime("%d.%m.%Y")
    logger.info(f"–ü–æ—Ç–æ—á–Ω–∞ –¥–∞—Ç–∞ EEST: {today}")

    row = [
        today,
        str(data.get("odometer", "")),
        str(data.get("diff", "")),
        str(int(data.get("city_km", 0))),
        str(data.get("city_exact", 0)).replace('.', ','),
        str(data.get("city_rounded", 0)),
        str(int(data.get("district_km", 0))),
        str(data.get("district_exact", 0)).replace('.', ','),
        str(data.get("district_rounded", 0)),
        str(int(data.get("highway_km", 0))),
        str(data.get("highway_exact", 0)).replace('.', ','),
        str(data.get("highway_rounded", 0)),
        str(data.get("total_exact", 0)).replace('.', ','),
        str(data.get("total_rounded", 0))
    ]

    try:
        start_time = time.time()
        sheet.append_row(row)
        update_sheet_cache()
        await query.edit_message_text(
            f"‚úÖ *–ó–∞–ø–∏—Å –∑–±–µ—Ä–µ–∂–µ–Ω–æ!* üéâ\n"
            f"üìÖ {today} | üìè {data['odometer']} –∫–º | üîÑ {data['diff']} –∫–º | ‚õΩ {data['total_exact']} –ª",
            parse_mode="Markdown"
        )
        logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {user_id} –∑–±–µ—Ä—ñ–≥ –∑–∞–ø–∏—Å: {row} –∑–∞ {time.time() - start_time:.3f} —Å–µ–∫")
    except Exception as e:
        await query.edit_message_text(f"‚ö†Ô∏è *–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è*: {e}", parse_mode="Markdown")
        logger.error(f"–ü–æ–º–∏–ª–∫–∞ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –∑–∞–ø–∏—Å—É: {e}")
        return ConversationHandler.END

    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    logger.info(f"–û—Ç—Ä–∏–º–∞–Ω–æ —Å–∫–∞—Å—É–≤–∞–Ω–Ω—è –≤—ñ–¥ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ {user_id}")
    user_data_store.pop(user_id, None)
    await query.edit_message_text("‚ùå *–û–ø–µ—Ä–∞—Ü—ñ—é —Å–∫–∞—Å–æ–≤–∞–Ω–æ.*", parse_mode="Markdown")
    logger.info(f"–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á {user_id} —Å–∫–∞—Å—É–≤–∞–≤ –æ–ø–µ—Ä–∞—Ü—ñ—é")
    return ConversationHandler.END

# –î–æ–¥–∞—î–º–æ –æ–±—Ä–æ–±–Ω–∏–∫–∏ –¥–æ application
conv_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(handle_button)],
    states={
        WAITING_FOR_ODOMETER: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_odometer)],
        WAITING_FOR_DISTRIBUTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_distribution)],
        CONFIRMATION: [CallbackQueryHandler(handle_confirmation)]
    },
    fallbacks=[CallbackQueryHandler(cancel, pattern="^cancel$")],
    per_user=True,
    per_chat=True,
    per_message=False
)

application.add_handler(CommandHandler("start", start))
application.add_handler(CommandHandler("stats", stats))
application.add_handler(conv_handler)

# –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è –≤–µ–±—Ö—É–∫–∞
@app.route('/webhook', methods=['POST'])
def webhook():
    try:
        update = Update.de_json(request.get_json(), application.bot)
        update_queue.put(update)
        logger.info(f"–û—Ç—Ä–∏–º–∞–Ω–æ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {update.update_id}")
        return 'ok'
    except Exception as e:
        logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –≤–µ–±—Ö—É–∫–∞: {e}")
        return 'error', 500

# –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è health check
@app.route('/health')
def health():
    return 'OK'

# –û–±—Ä–æ–±–Ω–∏–∫ –¥–ª—è favicon
@app.route('/favicon.ico')
def favicon():
    return '', 204

# –ì–æ–ª–æ–≤–Ω–∞ —Å—Ç–æ—Ä—ñ–Ω–∫–∞
@app.route('/')
def index():
    return 'Telegram Bot is running!'

def set_webhook():
    try:
        # –í–∏–¥–∞–ª—è—î–º–æ –±—É–¥—å-—è–∫—ñ –∫—ñ–Ω—Ü–µ–≤—ñ —Å–ª–µ—à—ñ –∑ WEBHOOK_URL
        webhook_url = WEBHOOK_URL.rstrip('/') + '/webhook'
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/setWebhook"
        response = requests.post(url, data={'url': webhook_url})
        if response.status_code == 200:
            logger.info(f"–í–µ–±—Ö—É–∫ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {webhook_url}")
        else:
            logger.error(f"–ü–æ–º–∏–ª–∫–∞ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–µ–±—Ö—É–∫–∞: {response.text}")
    except Exception as e:
        logger.error(f"–ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Å–ø—Ä–æ–±—ñ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –≤–µ–±—Ö—É–∫–∞: {e}")

async def process_updates():
    while True:
        if not update_queue.empty():
            update = update_queue.get()
            try:
                await application.process_update(update)
            except Exception as e:
                logger.error(f"–ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è: {e}")
        await asyncio.sleep(0.1)

def run_bot():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(application.initialize())
    loop.run_until_complete(application.start())
    loop.create_task(process_updates())
    try:
        loop.run_forever()
    except KeyboardInterrupt:
        pass
    finally:
        loop.run_until_complete(application.stop())
        loop.close()

if __name__ == '__main__':
    # –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –≤–µ–±—Ö—É–∫
    set_webhook()
    
    # –ó–∞–ø—É—Å–∫–∞—î–º–æ –±–æ—Ç–∞ –≤ –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ
    t = threading.Thread(target=run_bot, daemon=True)
    t.start()
    
    # –ó–∞–ø—É—Å–∫–∞—î–º–æ Flask
    app.run(host='0.0.0.0', port=int(RENDER_PORT), debug=False)
